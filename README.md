# Simple Authentication Server

This is a simple authentication server written in Python using the `http.server` and `socketserver` modules. It provides basic registration, login, and password recovery functionality.

## Features

- Registration: Users can register by providing a unique username, email, and password.
- Login: Registered users can log in using their username and password.
- Password Recovery: Users can request a password reset by providing their username. A new password will be generated and sent to them.
- Two-Factor Authentication: After successful login, users are required to enter a two-factor authentication (2FA) code generated by an authenticator app.

## Prerequisites

- Python 3.x
- `http.server` module (built-in)
- `socketserver` module (built-in)
- `urllib.parse` module (built-in)
- `os` module (built-in)
- `hashlib` module (built-in)
- `base64` module (built-in)
- `ssl` module (built-in)

## Usage

1. Clone the repository or download the code files.

   ```shell
   git clone https://github.com/igor20192/authentication_app.git

2. Generate SSL/TLS certificates (`server.crt` and `server.key`) for secure communication (optional but recommended).
3. Open a terminal or command prompt and navigate to the project directory.

   ```shell
   cd authentication_app

4. Check in and activate the Python virtual environment

   ```shell
   python3 -m venv env
   . env/bin/activate

5. Run the following command to start the authentication server:

   ```shell
   python auth_user.py

6. The server will start listening on the specified port (default: 8000) and serve the required HTML pages.
7. Access the server using a web browser at https://localhost:<PORT>, where <PORT> is the port number specified in the code.
8. Follow the on-screen instructions to register, log in, and perform other actions.
9. User registration go : https://localhost:8000
   Login : https://localhost:8000/login
   Change Password : https://localhost:8000/forgot_password
   Log out : https://localhost:8000:logout

## Implementation Description

1. In the code, the TLS protocol is implemented using the ssl module in Python. Here's how it goes:

   - Create an SSL/TLS context:

      ```shell
      # Create an SSL/TLS context

      context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
      context.load_cert_chain(certfile="server.crt", keyfile="server.key")

   This code creates an SSLContext object using the ssl.PROTOCOL_TLS_SERVER protocol. The certificate (server.crt) and the corresponding key (server.key) are then loaded using the load_cert_chain method to ensure a secure connection.

   - Applying an SSL/TLS context to a socket:

      ```shell
      httpd.socket = context.wrap_socket(httpd.socket)

   This code applies the SSL/TLS context to the server's socket httpd.socket. Now the server will accept encrypted connections using the TLS protocol.
   - Server start:

      ```shell
      httpd.serve_forever()

   - After applying the SSL/TLS context to the socket, the server starts up and starts listening for incoming requests on the specified port. All connections will be protected by the TLS protocol.

Note: The TLS protocol requires a valid
certificate, which you must provide in the form of server.crt files
certificate and server.key key. Make sure you have the correct
certificate and key, or generate them with tools like OpenSSL.

2. In the presented code, user registration occurs as follows:

   - When the client sends a POST request along the "/register" path (in the do_POST method), the server requests the registration form obtained from the request body:

      ```shell
      content_length = int(self.headers["Content-Length"])
      post_data = self.rfile.read(content_length).decode("utf-8")
      form_data = urllib.parse.parse_qs(post_data)

   - Then data is retrieved from forms such as username, email and password:

      ```shell
      username = form_data["username"][0]
      email = form_data["email"][0]
      password = form_data["password"][0]

   - After that, a check is made for the minimum password length:

      ```shell
      if len(password) < 8:
         # Return an error message if the password does not match minimum length

   - Next, checks are performed for the uniqueness of the username and email address:

      ```shell
      if username in users:
         # An error message is returned if the username is already exists

      if email in (users[username]["email"] for username in users):
         # An error message is returned if the email address is already exists

   - If all checks are successful, the password is hashed and stored in the users dictionary along with other user data:

      ```shell
      salt = os.urandom(16)
      password_hash = hashlib.pbkdf2_hmac("sha256", password.encode(), salt, 100000)

      users[username] = {
      "password_hash": password_hash,
      "salt": salt,
      "email": email,
      }

   - At the end, a message about successful registration is returned:

      ```shell
      response_message = "User successfully registered."
      self.send_response(200)
      self.send_header("Content-type", "text/html")
      self.end_headers()
      self.wfile.write(response_message.encode("utf-8"))

   Thus, when a user registers, the server validates the form data, performs several checks (including the password policy), hashes the password, and stores information about the user.

3. In the presented code, the user login (login) process is implemented in the do_POST method for the /login path. Here is a general overview of how a user logs in:

   - Retrieving form data: In the do_POST method, the server receives a POST request, extracts the data from the request body, and parses it using the urllib.parse module. The form data, including username and password, is retrieved as follows:

      ```shell
      post_data = self.rfile.read(content_length).decode("utf-8")
      form_data = urllib.parse.parse_qs(post_data)
      username = form_data["username"][0]
      password = form_data["password"][0]

   - Checking if the user exists: The server then checks if the user with the given name exists in the users database. If a user with the specified name does not exist, the server sends a response with the message "User is not found.".

   - Password validation: If the user exists, the server retrieves the password hash and salt from the database for the specified user. The server then hashes the entered password using the same salt and hashing algorithm, and then compares the resulting hash with the hash stored in the database:

      ```shell
      stored_password_hash = users[username]["password_hash"]
      stored_salt = users[username]["salt"]
      password_hash = hashlib.pbkdf2_hmac(
          "sha256", password.encode(), stored_salt, 100000
      )

      if password_hash != stored_password_hash:
          # Неправильный пароль
          self.send_response(200)
          self.send_header("Content-type", "text/html")
          self.end_headers()
          self.wfile.write("Wrong password.".encode("utf-8"))
          return

   If the hashes match, the server continues the login process.

   - 2FA secret key generation and storage: Upon successful password verification, the server generates a random two-factor authentication (2FA) secret key using the os.urandom function and encodes it in Base32 format. The server then stores the private key in the database for the corresponding user:

      ```shell
      twofa_secret = base64.b32encode(os.urandom(10)).decode()
      users[username]["twofa_secret"] = twofa_secret

   - Printing the secret key and sending a response: The server prints the generated 2FA secret key to the console for further use. The server then opens the secret_key.html file, replaces the {username} placeholder with the actual username, and sends the contents of the file in the response:

      ```shell
      with open("secret_key.html", "rb") as file:
         content = file.read().decode("utf-8")
      content = content.replace("{username}", username)
      self.send_response(200)
      self.send_header("Content-type", "text/html")
      self.end_headers()
      self.wfile.write(content.encode("utf-8"))

   So after submitting a form with a username and password, the server checks for the existence of the user, verifies that the password is correct, generates and stores the 2FA secret key, and then sends the secret key page in the response.

4. In the presented code, the password change process is implemented in the do_POST method for the /forgot_password path. Here is a general overview of how a user password change occurs:
    
   - Retrieving form data: In the do_POST method, the server receives a POST request, extracts the data from the request body, and parses it using the urllib.parse module. The form data, including the username, is retrieved as follows:

      ```shell
      post_data = self.rfile.read(content_length).decode("utf-8")
      form_data = urllib.parse.parse_qs(post_data)
      username = form_data["username"][0]

   - Checking if the user exists: The server then checks if the user with the given name exists in the users database. If a user with the specified name does not exist, the server sends a response with the message "User is not found.".

   - New password generation: If the user exists, the server generates a new random password using the os.urandom function and converts it to a hexadecimal representation:

      ```shell
      new_password = os.urandom(8).hex()

   - Hashing the new password: The server then generates a new salt, hashes the new password using the salt and the PBKDF2 hashing algorithm, and then updates the hash and salt in the database for the specified user:

      ```shell
      salt = os.urandom(16)
      password_hash = hashlib.pbkdf2_hmac(
          "sha256", new_password.encode(), salt, 100000
      )
      users[username]["password_hash"] = password_hash
      users[username]["salt"] = salt

   - Sending a new password to the user: The server sends a response with the newly generated password in the format "Your new password: {new_password}". The client browser receives this response and can display the new password to the user.

      ```shell
      self.send_response(200)
      self.send_header("Content-type", "text/html")
      self.end_headers()
      self.wfile.write(f"your new password: {new_password}".encode("utf-8"))

   So after submitting a form with a username, the server checks for the existence of the user, generates a new password, hashes it and updates the corresponding data in the database, and then sends the new password in the response. The user can use this new password to log in to the system.

5. In the presented code, the logout process (logout) is implemented in the do_GET method for the /logout path. Here is a general overview of how a user logs out:

   - Processing a GET request: When a user navigates to the /logout path, the server processes the GET request and executes the corresponding code in the do_GET method.

   - Response Shaping: The server sends a response with status code 200 and content type text/html. It then sends the message "You have successfully logged out." in response body:

      ```shell
      self.send_response(200)
      self.send_header("Content-type", "text/html")
      self.end_headers()
      self.wfile.write("You have successfully logged out.".encode("utf-8"))

   - Logout: Upon receiving this response, the client browser displays
   the message "You have successfully logged out." user. Additional
   actions such as clearing a user's session or deleting temporary
   data can be performed as needed.

   - Thus, to log out, the user must navigate to the /logout path. The server will send a response indicating successful logout and the user will be disconnected from the current session.






   










